package com.jb.backend.webserver.java.j2se.coretechnology.abstractclassandinterface;
/**
*@author Andy YE
*@date 2018年9月10日下午10:27:53
*
*	实现方式：使用abstract关键字的类
*	定义：含有抽象方法的类
*		a.必须使用关键字abstract修饰
*		b.抽象类不能直接实例化，也就是不能使用new关键字直接产生对象
*		c.抽象类中的抽象方法只需声明，无需实现
*		d.含有抽象方法的类必须声明为抽象类，抽象类的子类覆写所有抽象方法后才能被实例化，
*		而如果不希望实现抽象方法具体行为时，可以仅仅使用大括号就是代表抽象方法被实现
*		e.如果子类继承抽象父类后，仍然有抽象方法，那么子类依然为抽象类
*	作用：作为基类，作为模板
*	优点：无需实现所有方法
*	缺点：只能支持单继承
*	使用场景：
*	前提要点：
*		a.在抽象类中可以显式声明构造方法，如此，则子类也必须显式调用父类构造方法
*		b.抽象类不可使用final类修饰
*		c.外部抽象类不可使用static修饰，但内部抽象类可使用static修饰，此时该静态内部类实际上表示一个外部类
*
*	问题：抽象类是否可以作为子类对象的句柄？按照个人想法，应该不可以，因为，父类虽然有同样的接口，
*		但是没有实现，所以，就算抽象父类作为引用持有具体子类对象，也无法向上转型调用其方法
*/

public class Abstractclass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}

abstract class book{
	public abstract void print();
	
	static abstract class CD{
		public abstract void get();
	}
}

//继承内部抽象类，就相当于继承外部类
class JavaCD extends book.CD{
	@Override
	public void get() {
		// TODO Auto-generated method stub
		System.out.println("learning Java");
	}
}